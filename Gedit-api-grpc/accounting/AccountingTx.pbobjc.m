// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: accounting/accounting_tx.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "accounting/AccountingTx.pbobjc.h"
 #import "Common.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - ACCTXAccountingTxRoot

@implementation ACCTXAccountingTxRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - ACCTXAccountingTxRoot_FileDescriptor

static GPBFileDescriptor *ACCTXAccountingTxRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"accounting_tx"
                                                 objcPrefix:@"ACCTX"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - ACCTXUpsertJournalRequest

@implementation ACCTXUpsertJournalRequest

@dynamic eventOneOfCase;
@dynamic paymentCreatedEvent;
@dynamic userVerifiedEvent;
@dynamic storeCreatedEvent;

typedef struct ACCTXUpsertJournalRequest__storage_ {
  uint32_t _has_storage_[2];
  ACCTXPaymentCreatedEvent *paymentCreatedEvent;
  ACCTXUserVerifiedEvent *userVerifiedEvent;
  ACCTXStoreVerifiedEvent *storeCreatedEvent;
} ACCTXUpsertJournalRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "paymentCreatedEvent",
        .dataTypeSpecific.className = GPBStringifySymbol(ACCTXPaymentCreatedEvent),
        .number = ACCTXUpsertJournalRequest_FieldNumber_PaymentCreatedEvent,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ACCTXUpsertJournalRequest__storage_, paymentCreatedEvent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userVerifiedEvent",
        .dataTypeSpecific.className = GPBStringifySymbol(ACCTXUserVerifiedEvent),
        .number = ACCTXUpsertJournalRequest_FieldNumber_UserVerifiedEvent,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ACCTXUpsertJournalRequest__storage_, userVerifiedEvent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "storeCreatedEvent",
        .dataTypeSpecific.className = GPBStringifySymbol(ACCTXStoreVerifiedEvent),
        .number = ACCTXUpsertJournalRequest_FieldNumber_StoreCreatedEvent,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ACCTXUpsertJournalRequest__storage_, storeCreatedEvent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ACCTXUpsertJournalRequest class]
                                     rootClass:[ACCTXAccountingTxRoot class]
                                          file:ACCTXAccountingTxRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ACCTXUpsertJournalRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "event",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\023\000\002\021\000\003\021\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ACCTXUpsertJournalRequest_ClearEventOneOfCase(ACCTXUpsertJournalRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - ACCTXListJournalRequest

@implementation ACCTXListJournalRequest

@dynamic from;
@dynamic size;

typedef struct ACCTXListJournalRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t from;
  int32_t size;
} ACCTXListJournalRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "from",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXListJournalRequest_FieldNumber_From,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACCTXListJournalRequest__storage_, from),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXListJournalRequest_FieldNumber_Size,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACCTXListJournalRequest__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ACCTXListJournalRequest class]
                                     rootClass:[ACCTXAccountingTxRoot class]
                                          file:ACCTXAccountingTxRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ACCTXListJournalRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACCTXGetJournalRequest

@implementation ACCTXGetJournalRequest

@dynamic uuid;

typedef struct ACCTXGetJournalRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *uuid;
} ACCTXGetJournalRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXGetJournalRequest_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACCTXGetJournalRequest__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ACCTXGetJournalRequest class]
                                     rootClass:[ACCTXAccountingTxRoot class]
                                          file:ACCTXAccountingTxRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ACCTXGetJournalRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACCTXJournalResponse

@implementation ACCTXJournalResponse

@dynamic hasStatus, status;
@dynamic hasJournal, journal;

typedef struct ACCTXJournalResponse__storage_ {
  uint32_t _has_storage_[1];
  ACCTXJournal *journal;
  COMMONStatus *status;
} ACCTXJournalResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "journal",
        .dataTypeSpecific.className = GPBStringifySymbol(ACCTXJournal),
        .number = ACCTXJournalResponse_FieldNumber_Journal,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACCTXJournalResponse__storage_, journal),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = GPBStringifySymbol(COMMONStatus),
        .number = ACCTXJournalResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACCTXJournalResponse__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ACCTXJournalResponse class]
                                     rootClass:[ACCTXAccountingTxRoot class]
                                          file:ACCTXAccountingTxRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ACCTXJournalResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACCTXJournal

@implementation ACCTXJournal

@dynamic eventOneOfCase;
@dynamic uuid;
@dynamic created;
@dynamic paymentCreatedEvent;
@dynamic userVerifiedEvent;
@dynamic storeVerifiedEvent;
@dynamic postingsArray, postingsArray_Count;
@dynamic postingsCreated;

typedef struct ACCTXJournal__storage_ {
  uint32_t _has_storage_[2];
  ACCTXPaymentCreatedEvent *paymentCreatedEvent;
  ACCTXUserVerifiedEvent *userVerifiedEvent;
  ACCTXStoreVerifiedEvent *storeVerifiedEvent;
  NSString *uuid;
  NSMutableArray *postingsArray;
  int64_t created;
  int64_t postingsCreated;
} ACCTXJournal__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "paymentCreatedEvent",
        .dataTypeSpecific.className = GPBStringifySymbol(ACCTXPaymentCreatedEvent),
        .number = ACCTXJournal_FieldNumber_PaymentCreatedEvent,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ACCTXJournal__storage_, paymentCreatedEvent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userVerifiedEvent",
        .dataTypeSpecific.className = GPBStringifySymbol(ACCTXUserVerifiedEvent),
        .number = ACCTXJournal_FieldNumber_UserVerifiedEvent,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ACCTXJournal__storage_, userVerifiedEvent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "storeVerifiedEvent",
        .dataTypeSpecific.className = GPBStringifySymbol(ACCTXStoreVerifiedEvent),
        .number = ACCTXJournal_FieldNumber_StoreVerifiedEvent,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ACCTXJournal__storage_, storeVerifiedEvent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXJournal_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACCTXJournal__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "created",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXJournal_FieldNumber_Created,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACCTXJournal__storage_, created),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "postingsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ACCTXPosting),
        .number = ACCTXJournal_FieldNumber_PostingsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ACCTXJournal__storage_, postingsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "postingsCreated",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXJournal_FieldNumber_PostingsCreated,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ACCTXJournal__storage_, postingsCreated),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ACCTXJournal class]
                                     rootClass:[ACCTXAccountingTxRoot class]
                                          file:ACCTXAccountingTxRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ACCTXJournal__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "event",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\023\000\002\021\000\003\022\000\"\017\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void ACCTXJournal_ClearEventOneOfCase(ACCTXJournal *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - ACCTXPaymentCreatedEvent

@implementation ACCTXPaymentCreatedEvent

@dynamic uuid;
@dynamic payerId;
@dynamic payeeId;
@dynamic payeeStoreId;
@dynamic payeeWorkerId;
@dynamic shouldpay;
@dynamic actualpay;
@dynamic bonuspay;
@dynamic channel;
@dynamic created;

typedef struct ACCTXPaymentCreatedEvent__storage_ {
  uint32_t _has_storage_[1];
  int32_t shouldpay;
  int32_t actualpay;
  int32_t bonuspay;
  NSString *uuid;
  NSString *payerId;
  NSString *payeeId;
  NSString *payeeStoreId;
  NSString *payeeWorkerId;
  NSString *channel;
  int64_t created;
} ACCTXPaymentCreatedEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXPaymentCreatedEvent_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACCTXPaymentCreatedEvent__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "payerId",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXPaymentCreatedEvent_FieldNumber_PayerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACCTXPaymentCreatedEvent__storage_, payerId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "payeeId",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXPaymentCreatedEvent_FieldNumber_PayeeId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ACCTXPaymentCreatedEvent__storage_, payeeId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "payeeStoreId",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXPaymentCreatedEvent_FieldNumber_PayeeStoreId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ACCTXPaymentCreatedEvent__storage_, payeeStoreId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "payeeWorkerId",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXPaymentCreatedEvent_FieldNumber_PayeeWorkerId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ACCTXPaymentCreatedEvent__storage_, payeeWorkerId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "shouldpay",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXPaymentCreatedEvent_FieldNumber_Shouldpay,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ACCTXPaymentCreatedEvent__storage_, shouldpay),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "actualpay",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXPaymentCreatedEvent_FieldNumber_Actualpay,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ACCTXPaymentCreatedEvent__storage_, actualpay),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "bonuspay",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXPaymentCreatedEvent_FieldNumber_Bonuspay,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ACCTXPaymentCreatedEvent__storage_, bonuspay),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "channel",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXPaymentCreatedEvent_FieldNumber_Channel,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ACCTXPaymentCreatedEvent__storage_, channel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "created",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXPaymentCreatedEvent_FieldNumber_Created,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ACCTXPaymentCreatedEvent__storage_, created),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ACCTXPaymentCreatedEvent class]
                                     rootClass:[ACCTXAccountingTxRoot class]
                                          file:ACCTXAccountingTxRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ACCTXPaymentCreatedEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\013\007\000\014\007\000\r\014\000\016\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACCTXUserVerifiedEvent

@implementation ACCTXUserVerifiedEvent

@dynamic userId;
@dynamic introducerId;
@dynamic created;

typedef struct ACCTXUserVerifiedEvent__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  NSString *introducerId;
  int64_t created;
} ACCTXUserVerifiedEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXUserVerifiedEvent_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACCTXUserVerifiedEvent__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "introducerId",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXUserVerifiedEvent_FieldNumber_IntroducerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACCTXUserVerifiedEvent__storage_, introducerId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "created",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXUserVerifiedEvent_FieldNumber_Created,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ACCTXUserVerifiedEvent__storage_, created),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ACCTXUserVerifiedEvent class]
                                     rootClass:[ACCTXAccountingTxRoot class]
                                          file:ACCTXAccountingTxRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ACCTXUserVerifiedEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\013\006\000\014\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACCTXStoreVerifiedEvent

@implementation ACCTXStoreVerifiedEvent

@dynamic storeId;
@dynamic introducerId;
@dynamic storeOwnerId;
@dynamic created;

typedef struct ACCTXStoreVerifiedEvent__storage_ {
  uint32_t _has_storage_[1];
  NSString *storeId;
  NSString *introducerId;
  NSString *storeOwnerId;
  int64_t created;
} ACCTXStoreVerifiedEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "storeId",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXStoreVerifiedEvent_FieldNumber_StoreId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACCTXStoreVerifiedEvent__storage_, storeId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "introducerId",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXStoreVerifiedEvent_FieldNumber_IntroducerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACCTXStoreVerifiedEvent__storage_, introducerId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "storeOwnerId",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXStoreVerifiedEvent_FieldNumber_StoreOwnerId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ACCTXStoreVerifiedEvent__storage_, storeOwnerId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "created",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXStoreVerifiedEvent_FieldNumber_Created,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ACCTXStoreVerifiedEvent__storage_, created),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ACCTXStoreVerifiedEvent class]
                                     rootClass:[ACCTXAccountingTxRoot class]
                                          file:ACCTXAccountingTxRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ACCTXStoreVerifiedEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\013\007\000\014\014\000\r\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACCTXListPostingRequest

@implementation ACCTXListPostingRequest

@dynamic userId;
@dynamic accountId;
@dynamic journalId;
@dynamic from;
@dynamic size;

typedef struct ACCTXListPostingRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t from;
  int32_t size;
  NSString *userId;
  NSString *accountId;
  NSString *journalId;
} ACCTXListPostingRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXListPostingRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACCTXListPostingRequest__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "accountId",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXListPostingRequest_FieldNumber_AccountId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACCTXListPostingRequest__storage_, accountId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "journalId",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXListPostingRequest_FieldNumber_JournalId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ACCTXListPostingRequest__storage_, journalId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "from",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXListPostingRequest_FieldNumber_From,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ACCTXListPostingRequest__storage_, from),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXListPostingRequest_FieldNumber_Size,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ACCTXListPostingRequest__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ACCTXListPostingRequest class]
                                     rootClass:[ACCTXAccountingTxRoot class]
                                          file:ACCTXAccountingTxRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ACCTXListPostingRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\013\006\000\014\t\000\r\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACCTXGetPostingRequest

@implementation ACCTXGetPostingRequest

@dynamic uuid;

typedef struct ACCTXGetPostingRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *uuid;
} ACCTXGetPostingRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXGetPostingRequest_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACCTXGetPostingRequest__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ACCTXGetPostingRequest class]
                                     rootClass:[ACCTXAccountingTxRoot class]
                                          file:ACCTXAccountingTxRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ACCTXGetPostingRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACCTXPostingResponse

@implementation ACCTXPostingResponse

@dynamic hasStatus, status;
@dynamic hasPosting, posting;

typedef struct ACCTXPostingResponse__storage_ {
  uint32_t _has_storage_[1];
  ACCTXPosting *posting;
  COMMONStatus *status;
} ACCTXPostingResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "posting",
        .dataTypeSpecific.className = GPBStringifySymbol(ACCTXPosting),
        .number = ACCTXPostingResponse_FieldNumber_Posting,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACCTXPostingResponse__storage_, posting),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = GPBStringifySymbol(COMMONStatus),
        .number = ACCTXPostingResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACCTXPostingResponse__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ACCTXPostingResponse class]
                                     rootClass:[ACCTXAccountingTxRoot class]
                                          file:ACCTXAccountingTxRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ACCTXPostingResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACCTXPosting

@implementation ACCTXPosting

@dynamic uuid;
@dynamic userId;
@dynamic accountId;
@dynamic journalId;
@dynamic amount;
@dynamic created;
@dynamic comment;

typedef struct ACCTXPosting__storage_ {
  uint32_t _has_storage_[1];
  int32_t amount;
  NSString *uuid;
  NSString *userId;
  NSString *accountId;
  NSString *journalId;
  NSString *comment;
  int64_t created;
} ACCTXPosting__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXPosting_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACCTXPosting__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXPosting_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACCTXPosting__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "accountId",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXPosting_FieldNumber_AccountId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ACCTXPosting__storage_, accountId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "journalId",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXPosting_FieldNumber_JournalId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ACCTXPosting__storage_, journalId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXPosting_FieldNumber_Amount,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ACCTXPosting__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "created",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXPosting_FieldNumber_Created,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ACCTXPosting__storage_, created),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "comment",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXPosting_FieldNumber_Comment,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ACCTXPosting__storage_, comment),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ACCTXPosting class]
                                     rootClass:[ACCTXAccountingTxRoot class]
                                          file:ACCTXAccountingTxRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ACCTXPosting__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\013\006\000\014\t\000\r\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACCTXListBalanceRequest

@implementation ACCTXListBalanceRequest

@dynamic accountUuid;
@dynamic from;
@dynamic size;

typedef struct ACCTXListBalanceRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t from;
  int32_t size;
  NSString *accountUuid;
} ACCTXListBalanceRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountUuid",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXListBalanceRequest_FieldNumber_AccountUuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACCTXListBalanceRequest__storage_, accountUuid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "from",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXListBalanceRequest_FieldNumber_From,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACCTXListBalanceRequest__storage_, from),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXListBalanceRequest_FieldNumber_Size,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ACCTXListBalanceRequest__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ACCTXListBalanceRequest class]
                                     rootClass:[ACCTXAccountingTxRoot class]
                                          file:ACCTXAccountingTxRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ACCTXListBalanceRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACCTXBalanceResponse

@implementation ACCTXBalanceResponse

@dynamic hasStatus, status;
@dynamic hasBalance, balance;

typedef struct ACCTXBalanceResponse__storage_ {
  uint32_t _has_storage_[1];
  ACCTXBalance *balance;
  COMMONStatus *status;
} ACCTXBalanceResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "balance",
        .dataTypeSpecific.className = GPBStringifySymbol(ACCTXBalance),
        .number = ACCTXBalanceResponse_FieldNumber_Balance,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACCTXBalanceResponse__storage_, balance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = GPBStringifySymbol(COMMONStatus),
        .number = ACCTXBalanceResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACCTXBalanceResponse__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ACCTXBalanceResponse class]
                                     rootClass:[ACCTXAccountingTxRoot class]
                                          file:ACCTXAccountingTxRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ACCTXBalanceResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ACCTXBalance

@implementation ACCTXBalance

@dynamic accountUuid;
@dynamic previousBalance;
@dynamic previousDate;
@dynamic currentChanges;
@dynamic currentDate;
@dynamic currentBalance;

typedef struct ACCTXBalance__storage_ {
  uint32_t _has_storage_[1];
  int32_t previousBalance;
  int32_t currentChanges;
  int32_t currentBalance;
  NSString *accountUuid;
  int64_t previousDate;
  int64_t currentDate;
} ACCTXBalance__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountUuid",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXBalance_FieldNumber_AccountUuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ACCTXBalance__storage_, accountUuid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "previousBalance",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXBalance_FieldNumber_PreviousBalance,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ACCTXBalance__storage_, previousBalance),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "previousDate",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXBalance_FieldNumber_PreviousDate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ACCTXBalance__storage_, previousDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "currentChanges",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXBalance_FieldNumber_CurrentChanges,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ACCTXBalance__storage_, currentChanges),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "currentDate",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXBalance_FieldNumber_CurrentDate,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ACCTXBalance__storage_, currentDate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "currentBalance",
        .dataTypeSpecific.className = NULL,
        .number = ACCTXBalance_FieldNumber_CurrentBalance,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ACCTXBalance__storage_, currentBalance),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ACCTXBalance class]
                                     rootClass:[ACCTXAccountingTxRoot class]
                                          file:ACCTXAccountingTxRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ACCTXBalance__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001\013\000\017\017\000\020\014\000\021\016\000\022\013\000\023\016\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
