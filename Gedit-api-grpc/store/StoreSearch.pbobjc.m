// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: store/store_search.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "store/StoreSearch.pbobjc.h"
 #import "Common.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - STSCHStoreSearchRoot

@implementation STSCHStoreSearchRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - STSCHStoreSearchRoot_FileDescriptor

static GPBFileDescriptor *STSCHStoreSearchRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"store_search"
                                                 objcPrefix:@"STSCH"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - STSCHIndexRequest

@implementation STSCHIndexRequest

@dynamic uuid;
@dynamic name;
@dynamic logo;
@dynamic hasLocation, location;
@dynamic type;
@dynamic desc;
@dynamic bonusRate;

typedef struct STSCHIndexRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t bonusRate;
  NSString *uuid;
  NSString *name;
  NSString *logo;
  COMMONLocation *location;
  NSString *type;
  NSString *desc;
} STSCHIndexRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = STSCHIndexRequest_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(STSCHIndexRequest__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = STSCHIndexRequest_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(STSCHIndexRequest__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "logo",
        .dataTypeSpecific.className = NULL,
        .number = STSCHIndexRequest_FieldNumber_Logo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(STSCHIndexRequest__storage_, logo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "location",
        .dataTypeSpecific.className = GPBStringifySymbol(COMMONLocation),
        .number = STSCHIndexRequest_FieldNumber_Location,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(STSCHIndexRequest__storage_, location),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = STSCHIndexRequest_FieldNumber_Type,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(STSCHIndexRequest__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "desc",
        .dataTypeSpecific.className = NULL,
        .number = STSCHIndexRequest_FieldNumber_Desc,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(STSCHIndexRequest__storage_, desc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bonusRate",
        .dataTypeSpecific.className = NULL,
        .number = STSCHIndexRequest_FieldNumber_BonusRate,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(STSCHIndexRequest__storage_, bonusRate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[STSCHIndexRequest class]
                                     rootClass:[STSCHStoreSearchRoot class]
                                          file:STSCHStoreSearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(STSCHIndexRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\010\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - STSCHIndexResponse

@implementation STSCHIndexResponse

@dynamic hasStatus, status;
@dynamic uuid;

typedef struct STSCHIndexResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *uuid;
  COMMONStatus *status;
} STSCHIndexResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = STSCHIndexResponse_FieldNumber_Uuid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(STSCHIndexResponse__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = GPBStringifySymbol(COMMONStatus),
        .number = STSCHIndexResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(STSCHIndexResponse__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[STSCHIndexResponse class]
                                     rootClass:[STSCHStoreSearchRoot class]
                                          file:STSCHStoreSearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(STSCHIndexResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - STSCHDeleteRequest

@implementation STSCHDeleteRequest

@dynamic uuid;

typedef struct STSCHDeleteRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *uuid;
} STSCHDeleteRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = STSCHDeleteRequest_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(STSCHDeleteRequest__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[STSCHDeleteRequest class]
                                     rootClass:[STSCHStoreSearchRoot class]
                                          file:STSCHStoreSearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(STSCHDeleteRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - STSCHDeleteResponse

@implementation STSCHDeleteResponse

@dynamic hasStatus, status;
@dynamic uuid;

typedef struct STSCHDeleteResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *uuid;
  COMMONStatus *status;
} STSCHDeleteResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = STSCHDeleteResponse_FieldNumber_Uuid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(STSCHDeleteResponse__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = GPBStringifySymbol(COMMONStatus),
        .number = STSCHDeleteResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(STSCHDeleteResponse__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[STSCHDeleteResponse class]
                                     rootClass:[STSCHStoreSearchRoot class]
                                          file:STSCHStoreSearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(STSCHDeleteResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - STSCHSearchRequest

@implementation STSCHSearchRequest

@dynamic lat;
@dynamic lon;
@dynamic type;
@dynamic keyword;
@dynamic from;
@dynamic size;

typedef struct STSCHSearchRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t from;
  int32_t size;
  NSString *type;
  NSString *keyword;
  double lat;
  double lon;
} STSCHSearchRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lat",
        .dataTypeSpecific.className = NULL,
        .number = STSCHSearchRequest_FieldNumber_Lat,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(STSCHSearchRequest__storage_, lat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "lon",
        .dataTypeSpecific.className = NULL,
        .number = STSCHSearchRequest_FieldNumber_Lon,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(STSCHSearchRequest__storage_, lon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = STSCHSearchRequest_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(STSCHSearchRequest__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "keyword",
        .dataTypeSpecific.className = NULL,
        .number = STSCHSearchRequest_FieldNumber_Keyword,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(STSCHSearchRequest__storage_, keyword),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "from",
        .dataTypeSpecific.className = NULL,
        .number = STSCHSearchRequest_FieldNumber_From,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(STSCHSearchRequest__storage_, from),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = STSCHSearchRequest_FieldNumber_Size,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(STSCHSearchRequest__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[STSCHSearchRequest class]
                                     rootClass:[STSCHStoreSearchRoot class]
                                          file:STSCHStoreSearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(STSCHSearchRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - STSCHSearchResponse

@implementation STSCHSearchResponse

@dynamic hasStatus, status;
@dynamic uuid;
@dynamic name;
@dynamic logo;
@dynamic hasLocation, location;
@dynamic type;
@dynamic desc;
@dynamic bonusRate;
@dynamic from;

typedef struct STSCHSearchResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t bonusRate;
  int32_t from;
  NSString *uuid;
  NSString *name;
  NSString *logo;
  COMMONLocation *location;
  NSString *type;
  NSString *desc;
  COMMONStatus *status;
} STSCHSearchResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = STSCHSearchResponse_FieldNumber_Uuid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(STSCHSearchResponse__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = STSCHSearchResponse_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(STSCHSearchResponse__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "logo",
        .dataTypeSpecific.className = NULL,
        .number = STSCHSearchResponse_FieldNumber_Logo,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(STSCHSearchResponse__storage_, logo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "location",
        .dataTypeSpecific.className = GPBStringifySymbol(COMMONLocation),
        .number = STSCHSearchResponse_FieldNumber_Location,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(STSCHSearchResponse__storage_, location),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = STSCHSearchResponse_FieldNumber_Type,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(STSCHSearchResponse__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "desc",
        .dataTypeSpecific.className = NULL,
        .number = STSCHSearchResponse_FieldNumber_Desc,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(STSCHSearchResponse__storage_, desc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bonusRate",
        .dataTypeSpecific.className = NULL,
        .number = STSCHSearchResponse_FieldNumber_BonusRate,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(STSCHSearchResponse__storage_, bonusRate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "from",
        .dataTypeSpecific.className = NULL,
        .number = STSCHSearchResponse_FieldNumber_From,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(STSCHSearchResponse__storage_, from),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = GPBStringifySymbol(COMMONStatus),
        .number = STSCHSearchResponse_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(STSCHSearchResponse__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[STSCHSearchResponse class]
                                     rootClass:[STSCHStoreSearchRoot class]
                                          file:STSCHStoreSearchRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(STSCHSearchResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\010\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
